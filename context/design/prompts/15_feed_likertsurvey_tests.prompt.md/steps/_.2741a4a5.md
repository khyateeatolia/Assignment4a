---
timestamp: 'Sun Oct 19 2025 21:43:29 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251019_214329.338d62ea.md]]'
content_id: 2741a4a5c32f023499b8e7f4a624a0c65b71c85f345179dac6595eba10eeb68e
---

# Feed Concept Tests - LikertSurvey Format Rewrite

I need you to rewrite the Feed concept tests in the LikertSurvey format. I've provided you with the current Feed implementation and the LikertSurvey test structure as reference.

## Current Feed Implementation Context

Here are the files I generated based on your previous response:

### FeedConcept.ts (Current Implementation)

```typescript
// src/concepts/Feed/FeedConcept.ts
import { Collection, Document, Db } from "npm:mongodb";
import { EventBus, ItemListingService, MockEventBus } from "./mock-services.ts";
import {
  FeedView, ListingSummary, ListingId, Tag, CurrencyAmount,
  ListingCreatedEvent, ListingUpdatedEvent, ListingWithdrawnEvent, ListingSoldEvent, FeedUpdatedEvent,
  ItemListing, ListingStatus, FeedIndexDoc, PaginationOptions, FeedFilters
} from "./types.ts";
import { DatabaseError, InvalidInputError, ItemListingServiceError, ListingNotFoundError } from "./FeedErrors.ts";

/**
 * FeedConcept provides a browsable, filterable, and automatically updating view of active listings.
 * It maintains its own indexed collection of listing summaries for efficient querying.
 */
export class FeedConcept {
  private feedCollection: Collection<FeedIndexDoc>;
  private readonly FEED_COLLECTION_NAME = "feed_listings";
  private readonly eventBus: EventBus;
  private readonly itemListingService: ItemListingService;

  constructor(db: Db, eventBus: EventBus, itemListingService: ItemListingService) {
    this.feedCollection = db.collection<FeedIndexDoc>(this.FEED_COLLECTION_NAME);
    this.eventBus = eventBus;
    this.itemListingService = itemListingService;

    this.initIndexes().catch(err => {
      console.error("FeedConcept: Failed to initialize database indexes on startup:", err);
    });
    this.registerEventListeners();
  }

  // ... (rest of implementation methods)
  
  async get_latest(n: number, page: number = 1): Promise<FeedView>
  async filter_by_tag(tag: Tag, n: number, page: number = 1): Promise<FeedView>
  async filter_by_price(min: CurrencyAmount | undefined, max: CurrencyAmount | undefined, n: number, page: number = 1): Promise<FeedView>
  async filter_by_combined(tag: Tag | undefined, minPrice: CurrencyAmount | undefined, maxPrice: CurrencyAmount | undefined, n: number, page: number = 1): Promise<FeedView>
  async refresh_feed(): Promise<void>
}
```

### Current Test Structure (NOT LikertSurvey Format)

The current tests use nested `t.step` calls and traditional unit testing structure, which is NOT the LikertSurvey format.

## LikertSurvey Test Format Reference

Here's how the LikertSurvey tests are structured:

### LikertSurveyConcept.test.ts (Reference Format)

```typescript
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import LikertSurveyConcept from "./LikertSurveyConcept.ts";

const authorA = "author:Alice" as ID;
const respondentB = "respondent:Bob" as ID;
const respondentC = "respondent:Charlie" as ID;

Deno.test("Principle: Author creates survey, respondent answers, author views results", async () => {
  const [db, client] = await testDb();
  const surveyConcept = new LikertSurveyConcept(db);

  try {
    // 1. Author creates a survey with a 1-5 scale
    const createSurveyResult = await surveyConcept.createSurvey({
      author: authorA,
      title: "Customer Satisfaction",
      scaleMin: 1,
      scaleMax: 5,
    });
    assertNotEquals(
      "error" in createSurveyResult,
      true,
      "Survey creation should not fail.",
    );
    const { survey } = createSurveyResult as { survey: ID };
    assertExists(survey);

    // 2. Author adds several questions
    const addQ1Result = await surveyConcept.addQuestion({
      survey,
      text: "How satisfied are you with our product?",
    });
    assertNotEquals(
      "error" in addQ1Result,
      true,
      "Adding question 1 should not fail.",
    );
    const { question: q1 } = addQ1Result as { question: ID };

    // ... more workflow steps

  } finally {
    await client.close();
  }
});

Deno.test("Principle: Multiple respondents can answer the same survey", async () => {
  // ... complete workflow test
});

Deno.test("Principle: Author can view aggregated results", async () => {
  // ... complete workflow test
});
```

## Key LikertSurvey Format Requirements

1. **Principle-based test names**: Each test starts with `"Principle: [descriptive workflow]"`
2. **Single test per principle**: One `Deno.test` per complete workflow, no nested `t.step` calls
3. **Complete user journeys**: Each test covers a full workflow from start to finish
4. **Descriptive assertions**: Clear assertion messages explaining what should happen
5. **Database setup/teardown**: Each test manages its own database connection
6. **Workflow-focused**: Tests real user scenarios, not isolated functionality

## Feed Concept Test Principles Needed

Based on the Feed concept functionality, I need tests for these principles:

1. **Principle: Feed displays latest listings sorted by recency**
2. **Principle: Users can filter listings by tag while maintaining chronological order**
3. **Principle: Users can filter listings by price range while maintaining chronological order**
4. **Principle: Users can combine tag and price filters while maintaining chronological order**
5. **Principle: Feed automatically updates when listings are created, updated, or removed**
6. **Principle: Feed handles pagination correctly for large result sets**
7. **Principle: Feed gracefully handles errors and invalid inputs**

## Request

Please rewrite the Feed concept tests in the proper LikertSurvey format:

1. **Create principle-based test names** that describe complete user workflows
2. **Use single `Deno.test` per principle** (no nested `t.step` calls)
3. **Test complete workflows** from start to finish
4. **Include proper database setup/teardown** in each test
5. **Use descriptive assertion messages**
6. **Update the fake data** to be compatible with the LikertSurvey format
7. **Follow the same patterns** as the LikertSurvey tests

Please provide:

* Updated `FeedConcept.test.ts` in LikertSurvey format
* Updated `fake-data.ts` with LikertSurvey-compatible fake data
* Any necessary updates to `mock-services.ts` for the new test format

The tests should be comprehensive but follow the LikertSurvey principle-based workflow approach rather than traditional unit testing structure.
