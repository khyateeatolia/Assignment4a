---
timestamp: 'Thu Oct 16 2025 13:29:07 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251016_132907.d7ed1889.md]]'
content_id: c6cd5a2cdd309d6ad49862d79e0e4328895ebd31f141b02a1a6fac13cb210350
---

# Marketplace System Concept Specification

## Overview

A student marketplace system enabling verified users to list items, place bids, communicate through threads, and browse available listings.

## Concepts

### Concept A — UserAccount

**Purpose:** Authenticate students via school email, manage verified user identities, and maintain minimal editable profiles containing their listings, bids, and messages.

**Types:**

* EmailAddress
* UserId
* Username
* VerificationToken

**State:**

```
pending_verifications: Map<EmailAddress, VerificationToken>
users: Map<UserId -> { 
    email: EmailAddress, 
    username: Username, 
    avatarUrl: Url, 
    verifiedAt: Timestamp 
}]
profiles: Map<UserId -> { 
    bio?: String, 
    listings: List<ListingId>, 
    bids: List<BidId>, 
    threads: List<ThreadId> 
}]
```

**Actions:**

* `request_verification(email: EmailAddress) -> VerificationToken`
* `confirm_verification(token: VerificationToken, username: Username) -> UserId`
* `edit_avatar(userId: UserId, newAvatar: Url)`
* `edit_bio(userId: UserId, bio: String)`
* `delete_account(userId: UserId)`
* `view_profile(userId: UserId) -> ProfileView`

**Notifications / Side-effects:**

* UserVerified(UserId) emitted on confirmation
* Email with verification link sent on request\_verification
* UserDeleted(UserId) emitted on account deletion

**Notes:**

* Usernames are immutable
* Only avatars and bios are editable
* Profiles automatically synchronize listings, bids, and message threads
* UserAccount implicitly covers moderation (e.g., accounts may flag messages)

### Concept B — ItemListing

**Purpose:** Represent items available for sale or exchange, and manage their full lifecycle — creation, editing, withdrawal, and sale.

**Types:**

* ListingId
* UserId (seller)
* Tag
* CurrencyAmount

**State:**

```
listings: Map<ListingId -> { 
    seller: UserId, 
    title: String, 
    description: String, 
    photos: List<Url>, 
    tags: List<Tag>, 
    minAsk?: CurrencyAmount, 
    createdAt: Timestamp, 
    status: Enum{Active, Sold, Withdrawn}, 
    currentHighestBid?: BidId, 
    bidLog: List<BidId> 
}]
```

**Actions:**

* `create_listing(seller: UserId, title, description, photos, tags, minAsk?) -> ListingId`
* `update_listing(listingId: ListingId, fields)`
* `withdraw_listing(listingId: ListingId, seller: UserId)`
* `accept_bid(listingId: ListingId, bidId: BidId)`

**Notifications:**

* ListingCreated(ListingId)
* ListingUpdated(ListingId)
* ListingWithdrawn(ListingId)
* ListingSold(ListingId, BidId)

**Notes:**

* Each listing references only the seller's UserId, not their full record (maintains modular independence)
* Withdrawn listings disappear from the feed and seller's profile automatically
* accept\_bid triggers synchronization with Bidding and UserAccount

### Concept C — Bidding

**Purpose:** Enable users to place, view, and withdraw bids on active listings while maintaining transparent bid histories.

**Types:**

* BidId
* ListingId
* UserId
* CurrencyAmount

**State:**

```
bids_by_listing: Map<ListingId -> List<BidId>>
bid_records: Map<BidId -> { 
    bidder: UserId, 
    listing: ListingId, 
    amount: CurrencyAmount, 
    timestamp: Timestamp, 
    status: Enum{Active, Withdrawn} 
}]
```

**Actions:**

* `place_bid(bidder: UserId, listingId: ListingId, amount: CurrencyAmount) -> BidId`
* `withdraw_bid(bidId: BidId, bidder: UserId)`
* `get_bids(listingId: ListingId) -> [BidRecord]`
* `get_current_high(listingId: ListingId) -> BidId?`

**Notifications:**

* BidPlaced(ListingId, BidId)
* BidWithdrawn(BidId)

**Notes:**

* Bids cannot be edited once placed
* Withdrawn bids are hidden in both the listing's and bidder's profile views
* Independence preserved — ListingId is a foreign key, not a dependency

### Concept D — MessagingThread

**Purpose:** Support structured communication between users around a listing and track message flow without requiring a separate moderation concept.

**Types:**

* ThreadId
* ListingId
* UserId
* MessageId
* Message

**State:**

```
threads: Map<ThreadId -> { 
    listingId: ListingId, 
    participants: Set<UserId>, 
    messages: List<MessageId> 
}]
messages: Map<MessageId -> { 
    sender: UserId, 
    text: String, 
    attachments?: List<Url>, 
    timestamp: Timestamp, 
    flagged?: Boolean 
}]
```

**Actions:**

* `start_thread(user: UserId, listingId: ListingId) -> ThreadId`
* `post_message(threadId: ThreadId, user: UserId, text: String, attachments?)`
* `flag_message(threadId: ThreadId, messageId: MessageId, reason: String)`
* `mark_pickup_complete(threadId: ThreadId, user: UserId)`

**Notifications:**

* NewMessage(ThreadId, MessageId)
* MessageFlagged(ThreadId, MessageId)

**Notes:**

* Moderation is folded into UserAccount — flagging triggers a review by system admins via event emission, not a separate concept
* Threads are removed if either participant deletes their profile

### Concept E — Feed

**Purpose:** Provide a browsable, filterable view of available listings and synchronize with updates across listing states.

**Types:**

* FeedView
* ListingId
* Tag

**State:**

```
feedIndex: List<ListingId>
tagIndex: Map<Tag -> List<ListingId>>
priceIndex: Map<PriceRange -> List<ListingId>>
```

**Actions:**

* `get_latest(n: Int) -> FeedView`
* `filter_by_tag(tag: Tag) -> FeedView`
* `filter_by_price(min: CurrencyAmount, max: CurrencyAmount) -> FeedView`
* `refresh_feed()`

**Notifications:**

* FeedUpdated

**Notes:**

* Only active listings are indexed
* Automatically updates when listings are created, withdrawn, or sold
* Feed reads data by ID — no shared access to ItemListing internals

## Synchronizations

**Sync 1 — AuthRequired**

* When: create\_listing or place\_bid
* Where: UserAccount + ItemListing + Bidding
* Then: Verify UserId exists with verifiedAt ≠ null; reject otherwise
* Rationale: Enforces verified student access

**Sync 2 — Place Bid → Update Listing + Profile**

* When: Bidding.place\_bid
* Where: Bidding + ItemListing + UserAccount
* Then: Append bid to both bid\_records and ItemListing.bidLog. Update currentHighestBid if needed. Add BidId to bidder's profile
* Rationale: Keeps bid history transparent and synchronized

**Sync 3 — Accept Bid → Close Listing + Notify Buyer**

* When: ItemListing.accept\_bid
* Where: ItemListing + Bidding + MessagingThread + UserAccount
* Then: Set listing status = Sold, emit ListingSold, start a MessagingThread between buyer/seller, move item to "sold" in profile
* Rationale: Ensures consistent transaction closure

**Sync 4 — Withdraw Listing → Update Feed + Profiles**

* When: ItemListing.withdraw\_listing
* Where: ItemListing + Feed + UserAccount
* Then: Remove listing from feed and seller's active listings. Mark associated bids withdrawn
* Rationale: Keeps visibility consistent across feed and profile

**Sync 5 — Withdraw Bid → Update Listing + Profile**

* When: Bidding.withdraw\_bid
* Where: Bidding + ItemListing + UserAccount
* Then: Mark bid as Withdrawn, remove from listing's visible bidLog and bidder's profile
* Rationale: Maintains accurate bid visibility

**Sync 6 — Flag Message → Notify Reviewer**

* When: MessagingThread.flag\_message
* Where: MessagingThread + UserAccount
* Then: Emit MessageFlagged event for internal moderation workflow; does not break modularity
* Rationale: Integrates moderation via UserAccount events

**Sync 7 — Feed Refresh**

* When: ItemListing.create\_listing or ItemListing.update\_listing
* Where: ItemListing + Feed + UserAccount
* Then: Add or update listing in feed indexes. Add listing to seller's profile. Emit FeedUpdated
* Rationale: Keeps feed and profile pages synchronized with listing lifecycle

## Responsibilities for THIS PROMPT

* Read the linked specification and app description.
* Summarize the system at a high level (3–6 bullets): core concepts, data boundaries, persistence approach, and user flows.
* Identify backend modules we’ll build (names only) in the next steps.
* List immediate open questions/assumptions to clarify before coding (≤5 items).
* Do NOT propose code or APIs yet.

## Constraints

* Tech stack: Deno, TypeScript, MongoDB (Atlas), Deno tests.
* Concepts must remain independent; communicate via identifiers (no cross-DB reads).
* Tests should be programmatic and include operational principles and interesting scenarios.

## Output Format

Respond with:

1. High-level Summary
2. Modules To Implement Next
3. Open Questions / Assumptions
