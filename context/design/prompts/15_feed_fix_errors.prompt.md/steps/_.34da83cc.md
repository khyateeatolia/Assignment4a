---
timestamp: 'Sun Oct 19 2025 22:10:52 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251019_221052.a77faca2.md]]'
content_id: 34da83cc48d8e2537d5652ec89e721fbdc05af4c7466ea115fe81da92925989e
---

# Feed Concept Error Fix Prompt

## Context

I need you to fix the errors in the Feed concept implementation and tests. I've rewritten the tests in the LikertSurvey format as requested, but there are several errors that need to be resolved.

## Files to Review and Fix

### 1. Feed Concept Implementation

**File: `src/concepts/Feed/FeedConcept.ts`**

```typescript
import { ObjectId } from "npm:mongodb";
import { Db } from "npm:mongodb";
import { EventBus, ItemListingService, FeedIndexDoc, ListingSummary, CurrencyAmount, ListingCreatedEvent, ListingUpdatedEvent, ListingWithdrawnEvent, ListingSoldEvent, FeedUpdatedEvent } from "./types.ts";

export class FeedConcept {
  private db: Db;
  private eventBus: EventBus;
  private listingService: ItemListingService;
  private feedCollection: any;

  constructor(db: Db, eventBus: EventBus, listingService: ItemListingService) {
    this.db = db;
    this.eventBus = eventBus;
    this.listingService = listingService;
    this.feedCollection = db.collection("feed_index");
    this.initIndexes();
    this.registerEventListeners();
  }

  private async initIndexes() {
    try {
      await this.feedCollection.createIndex({ createdAt: -1 });
      await this.feedCollection.createIndex({ tags: 1 });
      await this.feedCollection.createIndex({ "price.value": 1 });
      await this.feedCollection.createIndex({ listingId: 1 }, { unique: true });
    } catch (error) {
      console.warn("Index creation failed:", error);
    }
  }

  private registerEventListeners() {
    this.eventBus.on("ListingCreatedEvent", (event: ListingCreatedEvent) => this._handleListingCreated(event));
    this.eventBus.on("ListingUpdatedEvent", (event: ListingUpdatedEvent) => this._handleListingUpdated(event));
    this.eventBus.on("ListingWithdrawnEvent", (event: ListingWithdrawnEvent) => this._handleListingWithdrawn(event));
    this.eventBus.on("ListingSoldEvent", (event: ListingSoldEvent) => this._handleListingSold(event));
  }

  private async _fetchListingDetails(listingId: string): Promise<any> {
    try {
      return await this.listingService.getListing(listingId);
    } catch (error) {
      console.error(`Failed to fetch listing ${listingId}:`, error);
      return null;
    }
  }

  private _createFeedIndexDoc(listing: any): FeedIndexDoc {
    return {
      _id: new ObjectId(),
      listingId: listing.id,
      title: listing.title,
      description: listing.description,
      price: listing.price,
      tags: listing.tags,
      imageUrl: listing.imageUrl,
      createdAt: listing.createdAt,
      lastUpdatedAt: listing.lastUpdatedAt,
      status: listing.status,
      ownerId: listing.ownerId
    };
  }

  private async _handleListingCreated(event: ListingCreatedEvent) {
    const listing = await this._fetchListingDetails(event.listingId);
    if (listing) {
      const feedDoc = this._createFeedIndexDoc(listing);
      await this.feedCollection.insertOne(feedDoc);
      await this.eventBus.emit("FeedUpdatedEvent", { message: "New listing added to feed" });
    }
  }

  private async _handleListingUpdated(event: ListingUpdatedEvent) {
    const listing = await this._fetchListingDetails(event.listingId);
    if (listing) {
      const feedDoc = this._createFeedIndexDoc(listing);
      await this.feedCollection.replaceOne({ listingId: event.listingId }, feedDoc);
      await this.eventBus.emit("FeedUpdatedEvent", { message: "Listing updated in feed" });
    }
  }

  private async _handleListingWithdrawn(event: ListingWithdrawnEvent) {
    await this.feedCollection.deleteOne({ listingId: event.listingId });
    await this.eventBus.emit("FeedUpdatedEvent", { message: "Listing withdrawn from feed" });
  }

  private async _handleListingSold(event: ListingSoldEvent) {
    await this.feedCollection.deleteOne({ listingId: event.listingId });
    await this.eventBus.emit("FeedUpdatedEvent", { message: "Listing sold and removed from feed" });
  }

  private _validatePriceRange(min?: CurrencyAmount, max?: CurrencyAmount): void {
    if (min && min.value < 0) {
      throw new Error("Minimum price must be a non-negative number.");
    }
    if (max && max.value < 0) {
      throw new Error("Maximum price must be a non-negative number.");
    }
    if (min && max && min.value > max.value) {
      throw new Error("Minimum price cannot be greater than maximum price.");
    }
  }

  private async _queryFeed(tags?: string[], minPrice?: CurrencyAmount, maxPrice?: CurrencyAmount): Promise<FeedIndexDoc[]> {
    const query: any = {};
    
    if (tags && tags.length > 0) {
      query.tags = { $in: tags };
    }
    
    if (minPrice || maxPrice) {
      query["price.value"] = {};
      if (minPrice) query["price.value"].$gte = minPrice.value;
      if (maxPrice) query["price.value"].$lte = maxPrice.value;
    }

    return await this.feedCollection.find(query).sort({ createdAt: -1 }).toArray();
  }

  private _buildFeedView(docs: FeedIndexDoc[]): ListingSummary[] {
    return docs.map(doc => ({
      id: doc.listingId,
      title: doc.title,
      description: doc.description,
      price: doc.price,
      tags: doc.tags,
      imageUrl: doc.imageUrl,
      createdAt: doc.createdAt,
      lastUpdatedAt: doc.lastUpdatedAt,
      status: doc.status,
      ownerId: doc.ownerId
    }));
  }

  async get_latest(n: number = 20): Promise<ListingSummary[]> {
    if (n <= 0) {
      throw new Error("Page size (n) must be a positive integer.");
    }
    
    const docs = await this.feedCollection.find({}).sort({ createdAt: -1 }).limit(n).toArray();
    return this._buildFeedView(docs);
  }

  async filter_by_tags(tags: string[], n: number = 20): Promise<ListingSummary[]> {
    if (n <= 0) {
      throw new Error("Page size (n) must be a positive integer.");
    }
    
    const docs = await this._queryFeed(tags);
    return this._buildFeedView(docs.slice(0, n));
  }

  async filter_by_price(min: CurrencyAmount, max: CurrencyAmount, n: number = 20): Promise<ListingSummary[]> {
    if (n <= 0) {
      throw new Error("Page size (n) must be a positive integer.");
    }
    
    this._validatePriceRange(min, max);
    const docs = await this._queryFeed(undefined, min, max);
    return this._buildFeedView(docs.slice(0, n));
  }

  async filter_by_tags_and_price(tags: string[], min: CurrencyAmount, max: CurrencyAmount, n: number = 20): Promise<ListingSummary[]> {
    if (n <= 0) {
      throw new Error("Page size (n) must be a positive integer.");
    }
    
    this._validatePriceRange(min, max);
    const docs = await this._queryFeed(tags, min, max);
    return this._buildFeedView(docs.slice(0, n));
  }

  async refresh_feed(): Promise<void> {
    await this.eventBus.emit("FeedUpdatedEvent", { message: "Feed refreshed" });
  }
}
```

### 2. Feed Concept Types

**File: `src/concepts/Feed/types.ts`**

```typescript
import { ObjectId } from "npm:mongodb";

export type ID = string;
export type ListingId = ID;
export type UserId = ID;

export interface CurrencyAmount {
  value: number;
  currency: string;
}

export interface ItemListing {
  id: ListingId;
  title: string;
  description: string;
  price: CurrencyAmount;
  tags: string[];
  imageUrl?: string;
  createdAt: Date;
  lastUpdatedAt: Date;
  status: "active" | "withdrawn" | "sold";
  ownerId: UserId;
}

export interface ListingSummary {
  id: ListingId;
  title: string;
  description: string;
  price: CurrencyAmount;
  tags: string[];
  imageUrl?: string;
  createdAt: Date;
  lastUpdatedAt: Date;
  status: "active" | "withdrawn" | "sold";
  ownerId: UserId;
}

export interface FeedIndexDoc {
  _id: ObjectId;
  listingId: ListingId;
  title: string;
  description: string;
  price: CurrencyAmount;
  tags: string[];
  imageUrl?: string;
  createdAt: Date;
  lastUpdatedAt: Date;
  status: "active" | "withdrawn" | "sold";
  ownerId: UserId;
}

export interface EventBus {
  on(eventName: string, callback: (data: any) => void | Promise<void>): void;
  emit(eventName: string, data: any): Promise<void>;
}

export interface ItemListingService {
  getListing(listingId: ListingId): Promise<ItemListing>;
  createListing(listing: Omit<ItemListing, "id" | "createdAt" | "lastUpdatedAt">): Promise<ItemListing>;
  updateListing(listingId: ListingId, updates: Partial<ItemListing>): Promise<ItemListing>;
  withdrawListing(listingId: ListingId, byUserId: UserId): Promise<void>;
  sellListing(listingId: ListingId, buyerId: UserId): Promise<void>;
}

export interface ListingCreatedEvent {
  listingId: ListingId;
  timestamp: Date;
}

export interface ListingUpdatedEvent {
  listingId: ListingId;
  timestamp: Date;
}

export interface ListingWithdrawnEvent {
  listingId: ListingId;
  byUserId: UserId;
  timestamp: Date;
}

export interface ListingSoldEvent {
  listingId: ListingId;
  buyerId: UserId;
  timestamp: Date;
}

export interface FeedUpdatedEvent {
  message: string;
}
```

### 3. Feed Concept Tests

**File: `src/concepts/Feed/FeedConcept.test.ts`**

```typescript
import { assertEquals, assert, assertRejects } from "jsr:@std/assert";
import { ObjectId } from "npm:mongodb";
import { FeedConcept } from "./FeedConcept.ts";
import { MockEventBus, MockItemListingService, setupTestDatabase } from "./mock-services.ts";
import { generateId, createMockListing, createManyMockListings } from "./fake-data.ts";
import { testDb } from "../../utils/database.ts";

Deno.test("Principle: Feed provides latest listings in reverse chronological order", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create test listings
    const listings = createManyMockListings(5);
    for (const listing of listings) {
      await listingService.createListing(listing);
      await eventBus.emit("ListingCreatedEvent", { listingId: listing.id, timestamp: new Date() });
    }

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Test get_latest
    const latest = await feed.get_latest(3);
    assertEquals(latest.length, 3);
    
    // Verify chronological order (most recent first)
    for (let i = 0; i < latest.length - 1; i++) {
      assert(latest[i].createdAt >= latest[i + 1].createdAt, "Listings should be in reverse chronological order");
    }
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Users can filter listings by tags while maintaining chronological order", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create test listings with different tags
    const electronicsListing = createMockListing({ tags: ["electronics", "gadgets"] });
    const clothingListing = createMockListing({ tags: ["clothing", "fashion"] });
    const electronicsListing2 = createMockListing({ tags: ["electronics", "computers"] });

    await listingService.createListing(electronicsListing);
    await listingService.createListing(clothingListing);
    await listingService.createListing(electronicsListing2);

    await eventBus.emit("ListingCreatedEvent", { listingId: electronicsListing.id, timestamp: new Date() });
    await eventBus.emit("ListingCreatedEvent", { listingId: clothingListing.id, timestamp: new Date() });
    await eventBus.emit("ListingCreatedEvent", { listingId: electronicsListing2.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Test tag filtering
    const electronicsResults = await feed.filter_by_tags(["electronics"]);
    assertEquals(electronicsResults.length, 2);
    
    // Verify all results have electronics tag
    for (const listing of electronicsResults) {
      assert(listing.tags.includes("electronics"), "All results should have electronics tag");
    }

    // Verify chronological order
    for (let i = 0; i < electronicsResults.length - 1; i++) {
      assert(electronicsResults[i].createdAt >= electronicsResults[i + 1].createdAt, "Filtered results should maintain chronological order");
    }
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Users can filter listings by price range while maintaining chronological order", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create test listings with different prices
    const cheapListing = createMockListing({ price: { value: 10, currency: "USD" } });
    const expensiveListing = createMockListing({ price: { value: 100, currency: "USD" } });
    const midRangeListing = createMockListing({ price: { value: 50, currency: "USD" } });

    await listingService.createListing(cheapListing);
    await listingService.createListing(expensiveListing);
    await listingService.createListing(midRangeListing);

    await eventBus.emit("ListingCreatedEvent", { listingId: cheapListing.id, timestamp: new Date() });
    await eventBus.emit("ListingCreatedEvent", { listingId: expensiveListing.id, timestamp: new Date() });
    await eventBus.emit("ListingCreatedEvent", { listingId: midRangeListing.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Test price filtering
    const midRangeResults = await feed.filter_by_price(
      { value: 20, currency: "USD" },
      { value: 80, currency: "USD" }
    );
    
    assertEquals(midRangeResults.length, 1);
    assertEquals(midRangeResults[0].price.value, 50);
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Users can combine tag and price filters while maintaining chronological order", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create test listings
    const electronicsCheap = createMockListing({ 
      tags: ["electronics"], 
      price: { value: 30, currency: "USD" } 
    });
    const electronicsExpensive = createMockListing({ 
      tags: ["electronics"], 
      price: { value: 150, currency: "USD" } 
    });
    const clothingCheap = createMockListing({ 
      tags: ["clothing"], 
      price: { value: 25, currency: "USD" } 
    });

    await listingService.createListing(electronicsCheap);
    await listingService.createListing(electronicsExpensive);
    await listingService.createListing(clothingCheap);

    await eventBus.emit("ListingCreatedEvent", { listingId: electronicsCheap.id, timestamp: new Date() });
    await eventBus.emit("ListingCreatedEvent", { listingId: electronicsExpensive.id, timestamp: new Date() });
    await eventBus.emit("ListingCreatedEvent", { listingId: clothingCheap.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Test combined filtering
    const results = await feed.filter_by_tags_and_price(
      ["electronics"],
      { value: 20, currency: "USD" },
      { value: 100, currency: "USD" }
    );
    
    assertEquals(results.length, 1);
    assertEquals(results[0].id, electronicsCheap.id);
    assert(results[0].tags.includes("electronics"));
    assertEquals(results[0].price.value, 30);
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Feed automatically updates when listings are created, updated, or removed", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create initial listing
    const listing1 = createMockListing({ title: "Initial Listing" });
    await listingService.createListing(listing1);
    await eventBus.emit("ListingCreatedEvent", { listingId: listing1.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify initial state
    let feedListings = await feed.get_latest(10);
    assertEquals(feedListings.length, 1);

    // Create second listing
    const listing2 = createMockListing({ title: "Second Listing" });
    await listingService.createListing(listing2);
    await eventBus.emit("ListingCreatedEvent", { listingId: listing2.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify update
    feedListings = await feed.get_latest(10);
    assertEquals(feedListings.length, 2);

    // Update listing
    const updatedListing = { ...listing1, title: "Updated Listing" };
    await listingService.updateListing(listing1.id, updatedListing);
    await eventBus.emit("ListingUpdatedEvent", { listingId: listing1.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify update
    feedListings = await feed.get_latest(10);
    assertEquals(feedListings.length, 2);
    const updatedInFeed = feedListings.find(l => l.id === listing1.id);
    assert(updatedInFeed, "Updated listing should be in feed");
    assertEquals(updatedInFeed.title, "Updated Listing");

    // Withdraw listing
    await listingService.withdrawListing(listing1.id, listing1.ownerId);
    await eventBus.emit("ListingWithdrawnEvent", { listingId: listing1.id, byUserId: listing1.ownerId, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify withdrawal
    feedListings = await feed.get_latest(10);
    assertEquals(feedListings.length, 1);
    assertEquals(feedListings[0].id, listing2.id);

    // Sell listing
    const soldListing = createMockListing({ title: "Sold Listing" });
    await listingService.createListing(soldListing);
    await eventBus.emit("ListingCreatedEvent", { listingId: soldListing.id, timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify sold listing is in feed
    feedListings = await feed.get_latest(10);
    assertEquals(feedListings.length, 2);

    // Sell the listing
    await listingService.sellListing(soldListing.id, "buyer123");
    await eventBus.emit("ListingSoldEvent", { listingId: soldListing.id, buyerId: "buyer123", timestamp: new Date() });

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify sold listing is removed
    feedListings = await feed.get_latest(10);
    assertEquals(feedListings.length, 1);
    assertEquals(feedListings[0].id, listing2.id);
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Feed handles invalid inputs gracefully", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Test invalid page size
    await assertRejects(
      () => feed.get_latest(0),
      Error,
      "Page size (n) must be a positive integer."
    );

    await assertRejects(
      () => feed.get_latest(-1),
      Error,
      "Page size (n) must be a positive integer."
    );

    // Test invalid price range
    await assertRejects(
      () => feed.filter_by_price(
        { value: -10, currency: "USD" },
        { value: 100, currency: "USD" }
      ),
      Error,
      "Minimum price must be a non-negative number."
    );

    await assertRejects(
      () => feed.filter_by_price(
        { value: 50, currency: "USD" },
        { value: 30, currency: "USD" }
      ),
      Error,
      "Minimum price cannot be greater than maximum price."
    );
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Feed maintains data consistency during concurrent operations", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create multiple listings concurrently
    const listings = createManyMockListings(10);
    const createPromises = listings.map(listing => 
      listingService.createListing(listing).then(() => 
        eventBus.emit("ListingCreatedEvent", { listingId: listing.id, timestamp: new Date() })
      )
    );

    await Promise.all(createPromises);

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 200));

    // Verify all listings are in feed
    const feedListings = await feed.get_latest(20);
    assertEquals(feedListings.length, 10);
  } finally {
    await client.close();
  }
});

Deno.test("Principle: Feed provides efficient querying capabilities", async () => {
  const [testDb, client] = await testDb();
  const eventBus = new MockEventBus();
  const listingService = new MockItemListingService();
  const feed = new FeedConcept(testDb, eventBus, listingService);

  try {
    // Create test data
    const listings = createManyMockListings(100);
    for (const listing of listings) {
      await listingService.createListing(listing);
      await eventBus.emit("ListingCreatedEvent", { listingId: listing.id, timestamp: new Date() });
    }

    // Wait for event processing
    await new Promise(resolve => setTimeout(resolve, 500));

    // Test performance of different operations
    const startTime = Date.now();
    
    await feed.get_latest(20);
    const getLatestTime = Date.now() - startTime;
    
    const filterStartTime = Date.now();
    await feed.filter_by_tags(["electronics"]);
    const filterTime = Date.now() - filterStartTime;
    
    const priceFilterStartTime = Date.now();
    await feed.filter_by_price(
      { value: 0, currency: "USD" },
      { value: 1000, currency: "USD" }
    );
    const priceFilterTime = Date.now() - priceFilterStartTime;

    // Verify reasonable performance (adjust thresholds as needed)
    assert(getLatestTime < 1000, `get_latest should complete within 1000ms, took ${getLatestTime}ms`);
    assert(filterTime < 1000, `filter_by_tags should complete within 1000ms, took ${filterTime}ms`);
    assert(priceFilterTime < 1000, `filter_by_price should complete within 1000ms, took ${priceFilterTime}ms`);
  } finally {
    await client.close();
  }
});
```

### 4. Feed Concept Mock Services

**File: `src/concepts/Feed/mock-services.ts`**

```typescript
import { EventBus, ItemListingService, ItemListing, ListingId, UserId } from "./types.ts";

export class MockEventBus implements EventBus {
  private events: Array<{ eventName: string; data: any }> = [];

  on(eventName: string, callback: (data: any) => void | Promise<void>): void {
    // Mock implementation - in real app, this would register the callback
  }

  async emit(eventName: string, data: any): Promise<void> {
    this.events.push({ eventName, data });
  }

  getEmittedEvents(): Array<{ eventName: string; data: any }> {
    return [...this.events];
  }

  clearEmittedEvents(): void {
    this.events = [];
  }
}

export class MockItemListingService implements ItemListingService {
  private listings: Map<ListingId, ItemListing> = new Map();

  async getListing(listingId: ListingId): Promise<ItemListing> {
    const listing = this.listings.get(listingId);
    if (!listing) {
      throw new Error(`Listing ${listingId} not found`);
    }
    return listing;
  }

  async createListing(listing: Omit<ItemListing, "id" | "createdAt" | "lastUpdatedAt">): Promise<ItemListing> {
    const newListing: ItemListing = {
      ...listing,
      id: `listing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date(),
      lastUpdatedAt: new Date()
    };
    this.listings.set(newListing.id, newListing);
    return newListing;
  }

  async updateListing(listingId: ListingId, updates: Partial<ItemListing>): Promise<ItemListing> {
    const existing = this.listings.get(listingId);
    if (!existing) {
      throw new Error(`Listing ${listingId} not found`);
    }
    const updated = { ...existing, ...updates, lastUpdatedAt: new Date() };
    this.listings.set(listingId, updated);
    return updated;
  }

  async withdrawListing(listingId: ListingId, byUserId: UserId): Promise<void> {
    const existing = this.listings.get(listingId);
    if (!existing) {
      throw new Error(`Listing ${listingId} not found`);
    }
    const updated = { ...existing, status: "withdrawn" as const, lastUpdatedAt: new Date() };
    this.listings.set(listingId, updated);
  }

  async sellListing(listingId: ListingId, buyerId: UserId): Promise<void> {
    const existing = this.listings.get(listingId);
    if (!existing) {
      throw new Error(`Listing ${listingId} not found`);
    }
    const updated = { ...existing, status: "sold" as const, lastUpdatedAt: new Date() };
    this.listings.set(listingId, updated);
  }
}

export async function setupTestDatabase() {
  const { testDb } = await import("../../utils/database.ts");
  return await testDb();
}
```

### 5. Feed Concept Fake Data

**File: `src/concepts/Feed/fake-data.ts`**

```typescript
import { ItemListing, CurrencyAmount } from "./types.ts";

export function generateId(): string {
  return `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

export function createMockListing(overrides: Partial<ItemListing> = {}): ItemListing {
  const id = generateId();
  const now = new Date();
  
  return {
    id,
    title: overrides.title || `Test Listing ${id}`,
    description: overrides.description || `Description for ${id}`,
    price: overrides.price || { value: Math.floor(Math.random() * 1000) + 10, currency: "USD" },
    tags: overrides.tags || ["general"],
    imageUrl: overrides.imageUrl || `https://example.com/image_${id}.jpg`,
    createdAt: overrides.createdAt || now,
    lastUpdatedAt: overrides.lastUpdatedAt || now,
    status: overrides.status || "active",
    ownerId: overrides.ownerId || `user_${id}`
  };
}

export function createManyMockListings(count: number, overrides: Partial<ItemListing> = {}): ItemListing[] {
  return Array.from({ length: count }, (_, index) => 
    createMockListing({
      ...overrides,
      title: overrides.title || `Test Listing ${index + 1}`,
      createdAt: new Date(Date.now() - (count - index) * 1000) // Stagger creation times
    })
  );
}
```

### 6. Feed Concept Errors

**File: `src/concepts/Feed/FeedErrors.ts`**

```typescript
export class FeedError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "FeedError";
  }
}

export class InvalidInputError extends FeedError {
  constructor(message: string) {
    super(message);
    this.name = "InvalidInputError";
  }
}

export class ListingNotFoundError extends FeedError {
  constructor(listingId: string) {
    super(`Listing ${listingId} not found`);
    this.name = "ListingNotFoundError";
  }
}

export class ItemListingServiceError extends FeedError {
  constructor(message: string) {
    super(message);
    this.name = "ItemListingServiceError";
  }
}

export class DatabaseError extends FeedError {
  constructor(message: string) {
    super(message);
    this.name = "DatabaseError";
  }
}
```

## Errors Encountered

When running the tests, I encountered the following errors:

1. **TypeScript Type Errors**: The `EventBus` interface was too restrictive, causing compatibility issues with `MockEventBus`.

2. **ObjectId vs String Type Mismatches**: The `ListingId` and `UserId` types were changed from `ObjectId` to `ID` (string), but some code was still using `ObjectId` methods.

3. **Duplicate Property Error**: The `tags` property was duplicated in the `createMockListing` function.

4. **Deno Permission Errors**: Missing `--allow-read` and `--allow-sys` flags for file system and system information access.

5. **Database Connection Leaks**: Tests were not properly closing MongoDB client connections, leading to session expiration errors.

6. **Assertion Errors**: Some test assertions were expecting different error messages than what the implementation was throwing.

7. **Test Logic Errors**: Some tests had incorrect logic, such as expecting 2 listings but getting 3 due to test setup issues.

## Request

Please review all the files and fix the errors. The main issues are:

1. Fix the type compatibility issues between `EventBus` interface and `MockEventBus` implementation
2. Ensure all `ObjectId` vs `ID` (string) type usage is consistent
3. Fix the duplicate property error in `fake-data.ts`
4. Ensure proper database connection management in tests
5. Fix assertion errors and test logic issues
6. Make sure all error messages match between implementation and tests

Please provide the corrected files with all errors resolved.
